#DSA #DSA-easy #Leetcode #linked-list #two-pointer #floyd-cycle-detection
# Problem Statement
Given head the head of a linked list determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list otherwise return false.
# Key Concepts
- **Floyd's Cycle Detection Algorithm (Tortoise and Hare)**: Use two pointers moving at different speeds
- **Fast Pointer**: Moves two steps at a time
- **Slow Pointer**: Moves one step at a time
- **Cycle Detection**: If there is a cycle the fast pointer will eventually meet the slow pointer
- **No Cycle**: If fast pointer reaches null there is no cycle
# Implementation Steps
1. **Initialize Two Pointers**: Set both fast and slow pointers to head
2. **Traverse the List**:
   - While fast is not null and fast->next is not null
   - Move fast two steps: fast = fast->next->next
   - Move slow one step: slow = slow->next
   - Check if fast == slow: if yes return true (cycle detected)
3. **No Cycle Found**: If loop exits return false
# Code Implementation
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
};
```
# Sample Input/Output
### Input
```plaintext
head = [3,2,0,-4], pos = 1
```
### Output
```plaintext
true
```
### Explanation
There is a cycle in the linked list where the tail connects to the 1st node (0-indexed). The fast and slow pointers will eventually meet inside the cycle.
### Input
```plaintext
head = [1,2], pos = 0
```
### Output
```plaintext
true
```
### Explanation
There is a cycle in the linked list where the tail connects to the 0th node. Both pointers will meet at the cycle.
### Input
```plaintext
head = [1], pos = -1
```
### Output
```plaintext
false
```
### Explanation
There is no cycle in the linked list. Fast pointer reaches null immediately.
# Dry Run
### Input: head = [3,2,0,-4], pos = 1 (cycle at node 2)
| Step | slow | fast | Action |
| ---- | ---- | ---- | ------ |
| 1 | 3 | 3 | Initialize both at head |
| 2 | 2 | 0 | slow moves 1 step, fast moves 2 steps |
| 3 | 0 | 2 | slow moves 1 step, fast moves 2 steps (wraps around cycle) |
| 4 | -4 | -4 | slow moves 1 step, fast moves 2 steps, fast == slow |
Result: true (cycle detected)
### Input: head = [1], pos = -1 (no cycle)
| Step | slow | fast | Action |
| ---- | ---- | ---- | ------ |
| 1 | 1 | 1 | Initialize both at head |
| 2 | - | - | fast->next is null, exit loop |
Result: false (no cycle)
# Notes
- **Efficiency**:
  - Time Complexity: O(n) where n is the number of nodes. In worst case with cycle both pointers traverse the list
  - Space Complexity: O(1) only two pointer variables used
- **Why It Works**: If there is a cycle the fast pointer will eventually lap the slow pointer and they will meet. If no cycle fast reaches null first
- **Alternative Approach**: Use a hash set to track visited nodes but requires O(n) space
- **Edge Cases**:
  - Empty list (head is null): Loop doesn't execute returns false
  - Single node no cycle: fast->next is null returns false
  - Single node with cycle to itself: Pointers meet immediately returns true
  - Two nodes with cycle: Works correctly
- **Key Invariant**: Fast pointer moves twice as fast so if cycle exists the distance between them decreases by 1 each iteration until they meet