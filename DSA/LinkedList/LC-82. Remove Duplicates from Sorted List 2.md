# Problem Statement
Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.
#DSA #LinkedList #DSA-easy #TwoPointer #Leetcode 
# Key Concepts
- **Dummy Node**: A placeholder node used to simplify edge cases, such as when the first node is part of a duplicate group.
- **Two-Pointer Technique**: Using `prev` to track the last unique node and `curr` to traverse the list.
- **In-Place Modification**: Modifying the linked list without using extra space.
# Implementation Steps
1. **Handle Edge Cases**: If the list is empty or has only one node, return the list as is.
2. **Create a Dummy Node**: Initialize a dummy node pointing to the head of the list to handle edge cases.
3. **Initialize Pointers**:
   - `prev`: Tracks the last confirmed unique node.
   - `curr`: Traverses the list node by node.
4. **Traverse the List**:
   - If duplicates are found, skip all nodes with the same value and re-link `prev->next` to the node after the duplicates.
   - If no duplicates are found, move `prev` to the current node.
5. **Return the Result**: Return the list starting from the node after the dummy.
# Code Implementation
```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }
        ListNode* dummy = new ListNode(0, head);
        ListNode* prev = dummy;
        ListNode* curr = head;
        while (curr != NULL) {
            if (curr->next != NULL && curr->val == curr->next->val) {
                while (curr->next != NULL && curr->val == curr->next->val) {
                    curr = curr->next;
                }
                prev->next = curr->next;
            } else {
                prev = curr;
            }
            curr = curr->next;
        }
        return dummy->next;
    }
};
```
# Sample Input/Output
### Input
```plaintext
head = [1,2,3,3,4,4,5]
```
### Output
```plaintext
[1,2,5]
```
### Explanation
- Start with `head = 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`.
- Compare adjacent nodes:
  - `1 != 2`: Move `prev` to `1`.
  - `2 != 3`: Move `prev` to `2`.
  - `3 == 3`: Skip duplicates → `prev->next = 4`.
  - `4 == 4`: Skip duplicates → `prev->next = 5`.
  - `5`: No duplicates → Move `prev` to `5`.
- Final result: `1 -> 2 -> 5`.
# Dry Run
### Input: head = [1,2,3,3,4,4,5]
1. Initialize `dummy = 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`.
2. Traverse the list:
   - `curr = 1`: No duplicates → Move `prev` to `1`.
   - `curr = 2`: No duplicates → Move `prev` to `2`.
   - `curr = 3`: Duplicates found → Skip → `prev->next = 4`.
   - `curr = 4`: Duplicates found → Skip → `prev->next = 5`.
   - `curr = 5`: No duplicates → Move `prev` to `5`.
3. Return `dummy->next = 1 -> 2 -> 5`.
# Notes
- **Efficiency**:
  - Time Complexity: O(n), as each node is visited once.
  - Space Complexity: O(1), as no extra data structures are used.
- **Edge Cases**:
  - Empty list (`head = nullptr`): Return `nullptr`.
  - List with one node: Return the same list.
  - List with all identical values: Return an empty list.