# Problem Statement
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
#DSA #LinkedList #DSA-easy #Leetcode 
# Key Concepts
- **Linked List Traversal**: Iterating through the linked list to examine each node.
- **Duplicate Removal**: Re-linking nodes to skip duplicates.
- **In-Place Modification**: Modifying the linked list without using extra space.
# Implementation Steps
1. **Initialize a Pointer**: Start with a pointer (`head`) at the beginning of the list.
2. **Iterate Through the List**: Use a loop to traverse the list while ensuring the current node and its next node are not null.
3. **Check for Duplicates**:
   - If the current node's value equals the next node's value, skip the next node by re-linking.
   - Otherwise, move the pointer to the next node.
4. **Return the Result**: Return the modified list starting from the original head.
# Code Implementation
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* res = head;
        while (head && head->next) {
            if (head->val == head->next->val) {
                head->next = head->next->next;
            } else {
                head = head->next;
            }
        }
        return res;
    }
};
```
# Sample Input/Output
### Input
```plaintext
head = [1,1,2,3,3]
```
### Output
```plaintext
[1,2,3]
```
### Explanation
- Start with `head = 1 -> 1 -> 2 -> 3 -> 3`.
- Compare adjacent nodes:
  - `1 == 1`: Remove duplicate → `1 -> 2 -> 3 -> 3`.
  - `1 != 2`: Move to next node.
  - `2 != 3`: Move to next node.
  - `3 == 3`: Remove duplicate → `1 -> 2 -> 3`.
- Final result: `1 -> 2 -> 3`.
# Dry Run
### Input: head = [1,1,2,3,3]
1. Initialize `res = head = 1 -> 1 -> 2 -> 3 -> 3`.
2. Traverse the list:
   - `head = 1`: `1 == 1` → Remove duplicate → `1 -> 2 -> 3 -> 3`.
   - `head = 1`: `1 != 2` → Move to next node.
   - `head = 2`: `2 != 3` → Move to next node.
   - `head = 3`: `3 == 3` → Remove duplicate → `1 -> 2 -> 3`.
3. Return `res = 1 -> 2 -> 3`.
# Notes
- **Efficiency**: The algorithm runs in O(n) time, where n is the number of nodes in the list.
- **Space Complexity**: O(1), as the list is modified in-place without using extra data structures.
- **Edge Cases**:
  - Empty list (`head = nullptr`): Return `nullptr`.
  - List with one node: Return the same list.
  - List with all identical values: Return a single-node list.