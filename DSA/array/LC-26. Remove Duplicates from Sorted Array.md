# Problem Statement
Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.
#array #DSA #DSA-easy #leetcode #TwoPointer 
# Key Concepts
- **In-Place Modification**: Modify the array without using extra space.
- **Two-Pointer Technique**: Use two pointers to track the current position and the next unique element.
- **Sorted Array**: Leverage the sorted property of the array to identify duplicates.
# Implementation Steps
1. **Check for Empty Array**: If the array is empty, return 0.
2. **Initialize Pointer `i`**: Set `i = 1`. This pointer marks the position where the next unique element will be placed.
3. **Iterate Through the Array**:
   - Use a pointer `j` to traverse the array starting from index 1.
   - Compare `nums[j]` with `nums[i - 1]`.
   - If a new unique element is found:
     - Copy `nums[j]` into `nums[i]`.
     - Increment `i` by 1.
   - If a duplicate is found, skip it.
4. **Return the Count of Unique Elements**: The final value of `i` represents the length of the unique portion of the array.
# Code Implementation
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;
        int i = 1;
        for (int j = 1; j < nums.size(); j++) {
            if (nums[j] != nums[i - 1]) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [1,1,2]
```
### Output
```plaintext
2, nums = [1,2,_]
```
### Explanation
- Start with `nums = [1,1,2]`.
- Compare adjacent elements:
  - `nums[1] == nums[0]`: Duplicate → Skip.
  - `nums[2] != nums[0]`: New unique → Copy `nums[2]` to `nums[1]`.
- Final result: `nums = [1,2,_]`, `k = 2`.
### Input
```plaintext
nums = [0,0,1,1,1,2,2,3,3,4]
```
### Output
```plaintext
5, nums = [0,1,2,3,4,_,_,_,_,_]
```
### Explanation
- Start with `nums = [0,0,1,1,1,2,2,3,3,4]`.
- Compare adjacent elements:
  - `nums[1] == nums[0]`: Duplicate → Skip.
  - `nums[2] != nums[0]`: New unique → Copy `nums[2]` to `nums[1]`.
  - Continue until the end of the array.
- Final result: `nums = [0,1,2,3,4,_,_,_,_,_]`, `k = 5`.
# Dry Run
### Input: nums = [0,0,1,1,1,2,2,3,3,4]
| Step | j | nums[j] | nums[i-1] | Action                     | i |
| ---- | - | ------- | --------- | -------------------------- | - |
| 1    | 1 | 0       | 0         | Duplicate → Skip           | 1 |
| 2    | 2 | 1       | 0         | New → Copy to nums[i], i++ | 2 |
| 3    | 3 | 1       | 1         | Duplicate → Skip           | 2 |
| 4    | 4 | 1       | 1         | Duplicate → Skip           | 2 |
| 5    | 5 | 2       | 1         | New → Copy to nums[i], i++ | 3 |
| 6    | 6 | 2       | 2         | Duplicate → Skip           | 3 |
| 7    | 7 | 3       | 2         | New → Copy to nums[i], i++ | 4 |
| 8    | 8 | 3       | 3         | Duplicate → Skip           | 4 |
| 9    | 9 | 4       | 3         | New → Copy to nums[i], i++ | 5 |
Final result: `nums = [0,1,2,3,4,_,_,_,_,_]`, `k = 5`.
# Notes
- **Efficiency**:
  - Time Complexity: O(n), where n is the size of the array.
  - Space Complexity: O(1), as the array is modified in-place.
- **Edge Cases**:
  - Empty array: Return 0.
  - Array with all identical elements: Return 1.
  - Array with no duplicates: Return the size of the array.