# Problem Statement
Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.
# Key Concepts
- **Counting Sort**: Count the frequency of each color and reconstruct the array.
- **Dutch National Flag Algorithm**: Use three pointers (`low`, `mid`, `high`) for a one-pass solution with constant space.
- **In-Place Sorting**: Sort the array without using extra space.
# Implementation Steps
### Approach 1: Counting Sort (Two-Pass)
1. **Count Frequencies**: Traverse the array and count the occurrences of `0`, `1`, and `2`.
2. **Reconstruct Array**:
   - Fill the first part with `0`s.
   - Fill the middle part with `1`s.
   - Fill the last part with `2`s.
### Approach 2: Dutch National Flag Algorithm (One-Pass)
1. **Initialize Pointers**:
   - `low = 0`: Position for the next `0`.
   - `mid = 0`: Current element being examined.
   - `high = n - 1`: Position for the next `2`.
2. **Traverse the Array**:
   - If `nums[mid] == 0`: Swap with `nums[low]`, increment `low` and `mid`.
   - If `nums[mid] == 1`: Increment `mid`.
   - If `nums[mid] == 2`: Swap with `nums[high]`, decrement `high`.
3. **Continue Until `mid > high`**.
# Code Implementation
### Approach 1: Counting Sort (Two-Pass)
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int zeroes = 0, ones = 0, twos = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                zeroes++;
            } else if (nums[i] == 1) {
                ones++;
            } else {
                twos++;
            }
        }
        for (int i = 0; i < zeroes; i++) {
            nums[i] = 0;
        }
        for (int i = zeroes; i < zeroes + ones; i++) {
            nums[i] = 1;
        }
        for (int i = zeroes + ones; i < zeroes + ones + twos; i++) {
            nums[i] = 2;
        }
    }
};
```
### Approach 2: Dutch National Flag Algorithm (One-Pass)
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int low = 0, mid = 0, high = nums.size() - 1;
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums[low], nums[mid]);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else {
                swap(nums[mid], nums[high]);
                high--;
            }
        }
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [2,0,2,1,1,0]
```
### Output
```plaintext
[0,0,1,1,2,2]
```
### Explanation
- Count frequencies: `zeroes = 2`, `ones = 2`, `twos = 2`.
- Reconstruct: `[0,0,1,1,2,2]`.
### Input
```plaintext
nums = [2,0,1]
```
### Output
```plaintext
[0,1,2]
```
### Explanation
- Count frequencies: `zeroes = 1`, `ones = 1`, `twos = 1`.
- Reconstruct: `[0,1,2]`.
# Dry Run
### Input: nums = [2,0,2,1,1,0]
#### Approach 1: Counting Sort
| Step | Action                     | Result         |
| ---- | -------------------------- | -------------- |
| 1    | Count: `zeroes=2, ones=2, twos=2` | -              |
| 2    | Fill `0`s (0 to 1)         | [0,0,2,1,1,0]  |
| 3    | Fill `1`s (2 to 3)         | [0,0,1,1,1,0]  |
| 4    | Fill `2`s (4 to 5)         | [0,0,1,1,2,2]  |
#### Approach 2: Dutch National Flag
| Step | mid | nums[mid] | Action             | nums           | low | high |
| ---- | --- | --------- | ------------------ | -------------- | --- | ---- |
| 1    | 0   | 2         | Swap with high     | [0,0,2,1,1,2]  | 0   | 4    |
| 2    | 0   | 0         | Swap with low      | [0,0,2,1,1,2]  | 1   | 4    |
| 3    | 1   | 0         | Swap with low      | [0,0,2,1,1,2]  | 2   | 4    |
| 4    | 2   | 2         | Swap with high     | [0,0,1,1,2,2]  | 2   | 3    |
| 5    | 2   | 1         | Increment mid      | [0,0,1,1,2,2]  | 2   | 3    |
| 6    | 3   | 1         | Increment mid      | [0,0,1,1,2,2]  | 2   | 3    |
Final result: `[0,0,1,1,2,2]`.
# Notes
- **Efficiency**:
  - Approach 1 (Counting Sort):
    - Time Complexity: O(n), two passes through the array.
    - Space Complexity: O(1), only counting variables used.
  - Approach 2 (Dutch National Flag):
    - Time Complexity: O(n), single pass through the array.
    - Space Complexity: O(1), only pointer variables used.
- **Edge Cases**:
  - Array with all same colors: No changes needed.
  - Array already sorted: No changes needed.
  - Single-element array: No changes needed.