# Problem Statement
Given a binary array `nums`, return the maximum number of consecutive `1`s in the array.
#Array #DSA #DSA-easy #Leetcode 
# Key Concepts
- **Binary Array**: The array contains only `0`s and `1`s.
- **Consecutive Count**: Count the number of consecutive `1`s and track the maximum count.
- **In-Place Calculation**: Use a single traversal of the array to compute the result.
# Implementation Steps
1. **Initialize Variables**:
   - `count`: Tracks the current streak of consecutive `1`s.
   - `max`: Tracks the maximum streak of consecutive `1`s.
2. **Traverse the Array**:
   - If the current element is `1`, increment `count`.
   - If the current element is `0`, reset `count` to `0`.
   - Update `max` if `count` exceeds the current `max`.
3. **Return the Result**:
   - Return the value of `max` after traversing the array.
# Code Implementation
```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int n = nums.size();
        int max = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                count++;
            } else {
                count = 0;
            }
            if (count > max) {
                max = count;
            }
        }
        return max;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [1,1,0,1,1,1]
```
### Output
```plaintext
3
```
### Explanation
- Traverse the array:
  - `nums[0] = 1`: Increment `count = 1`, update `max = 1`.
  - `nums[1] = 1`: Increment `count = 2`, update `max = 2`.
  - `nums[2] = 0`: Reset `count = 0`.
  - `nums[3] = 1`: Increment `count = 1`.
  - `nums[4] = 1`: Increment `count = 2`.
  - `nums[5] = 1`: Increment `count = 3`, update `max = 3`.
- Final result: `max = 3`.
### Input
```plaintext
nums = [1,0,1,1,0,1]
```
### Output
```plaintext
2
```
### Explanation
- Traverse the array:
  - `nums[0] = 1`: Increment `count = 1`, update `max = 1`.
  - `nums[1] = 0`: Reset `count = 0`.
  - `nums[2] = 1`: Increment `count = 1`.
  - `nums[3] = 1`: Increment `count = 2`, update `max = 2`.
  - `nums[4] = 0`: Reset `count = 0`.
  - `nums[5] = 1`: Increment `count = 1`.
- Final result: `max = 2`.
# Dry Run
### Input: nums = [1,1,0,1,1,1]
| Step | nums[i] | count | max |
| ---- | ------- | ----- | --- |
| 1    | 1       | 1     | 1   |
| 2    | 1       | 2     | 2   |
| 3    | 0       | 0     | 2   |
| 4    | 1       | 1     | 2   |
| 5    | 1       | 2     | 2   |
| 6    | 1       | 3     | 3   |
Final result: `max = 3`.
# Notes
- **Efficiency**:
  - Time Complexity: O(n), where `n` is the size of the array.
  - Space Complexity: O(1), as no extra space is used.
- **Edge Cases**:
  - Array with all `1`s: Return the size of the array.
  - Array with all `0`s: Return `0`.
  - Single-element array: Return `1` if the element is `1`, otherwise `0`.