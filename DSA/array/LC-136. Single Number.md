# Problem Statement
Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
#Array #DSA #DSA-easy #Leetcode #Bitwise
# Key Concepts
- **XOR Properties**:
  - `a ^ a = 0` (XOR of two identical numbers is 0)
  - `a ^ 0 = a` (XOR of any number with 0 is the number itself)
  - XOR is commutative and associative
- **Map Approach**: Use a map to count the frequency of each element and return the element with a frequency of 1.
- **Optimal Approach**: Use XOR to find the single number in O(n) time with O(1) space.
# Implementation Steps
### Approach 1: Using a Map
1. **Initialize a Map**: Create a map to store the frequency of each element.
2. **Traverse the Array**: For each element, increment its count in the map.
3. **Find the Single Number**: Traverse the map and return the element with a frequency of 1.
### Approach 2: Using XOR (Optimal)
1. **Initialize Result**: Set `result = 0`.
2. **Traverse the Array**: For each element, XOR it with `result`.
3. **Return Result**: After traversing the array, `result` will hold the single number.
4. Why this always works
Because of two properties:
5. **Commutative:** `a ^ b = b ^ a`
6. **Associative:** `(a ^ b) ^ c = a ^ (b ^ c)`
That means **order doesn’t matter** — so no matter how numbers are arranged, pairs will cancel out.
All pairs become 0, and only the unique number remains.
Example:
```
[4, 1, 2, 1, 2] 
4 ^ 1 ^ 2 ^ 1 ^ 2 
(1 ^ 1) ^ (2 ^ 2) ^ 4 
0 ^ 0 ^ 4 → 4`
```
# Code Implementation
### Approach 1: Using a Map
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            mp[nums[i]]++;
        }
        for (auto it : mp) {
            if (it.second == 1) {
                return it.first;
            }
        }
        return -1;
    }
};
```
### Approach 2: Using XOR (Optimal)
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int i = 0; i < nums.size(); i++) {
            result = result ^ nums[i];
        }
        return result;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [2,2,1]
```
### Output
```plaintext
1
```
### Explanation
- Using XOR:
  - `result = 0 ^ 2 = 2`
  - `result = 2 ^ 2 = 0`
  - `result = 0 ^ 1 = 1`
- Final result: `1`.
### Input
```plaintext
nums = [4,1,2,1,2]
```
### Output
```plaintext
4
```
### Explanation
- Using XOR:
  - `result = 0 ^ 4 = 4`
  - `result = 4 ^ 1 = 5`
  - `result = 5 ^ 2 = 7`
  - `result = 7 ^ 1 = 6`
  - `result = 6 ^ 2 = 4`
- Final result: `4`.
### Input
```plaintext
nums = [1]
```
### Output
```plaintext
1
```
### Explanation
- The array contains only one element, which is the single number.
# Dry Run
### Input: nums = [4,1,2,1,2]
| Step | nums[i] | result (binary) | result (decimal) |
| ---- | ------- | --------------- | ---------------- |
| 1    | 4       | 100             | 4                |
| 2    | 1       | 101             | 5                |
| 3    | 2       | 111             | 7                |
| 4    | 1       | 110             | 6                |
| 5    | 2       | 100             | 4                |
Final result: `4`.
# Notes
- **Efficiency**:
  - Approach 1 (Map):
    - Time Complexity: O(n), where `n` is the size of the array.
    - Space Complexity: O(n), for storing elements in the map.
  - Approach 2 (XOR):
    - Time Complexity: O(n), where `n` is the size of the array.
    - Space Complexity: O(1), as no extra space is used.
- **Edge Cases**:
  - Single-element array: Return the single element.
  - Array with all elements appearing twice except one: Return the single element.