# Problem Statement
Given an integer array `nums`, find the subarray with the largest sum, and return its sum.
#Array #DSA #DSA-easy #Leetcode 
# Key Concepts
- **Kadane's Algorithm**: An efficient algorithm to find the maximum sum of a contiguous subarray in O(n) time.
- **Current Sum Tracking**: Maintain a running sum of the current subarray and reset it to 0 when it becomes negative.
- **Maximum Sum**: Track the maximum sum encountered during the traversal.
# Implementation Steps
1. **Initialize Variables**:
   - `maxSum = nums[0]`: Stores the maximum sum found so far.
   - `currentSum = 0`: Tracks the sum of the current subarray.
2. **Traverse the Array**:
   - Add the current element to `currentSum`.
   - Update `maxSum` if `currentSum` exceeds it.
   - If `currentSum` becomes negative, reset it to 0 (discard the current subarray).
3. **Return the Result**: Return `maxSum` after traversing the array.
# Code Implementation
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];
        int currentSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            currentSum = currentSum + nums[i];
            maxSum = max(currentSum, maxSum);
            if (currentSum < 0) {
                currentSum = 0;
            }
        }
        return maxSum;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [-2,1,-3,4,-1,2,1,-5,4]
```
### Output
```plaintext
6
```
### Explanation
- The subarray `[4,-1,2,1]` has the largest sum `6`.
- Traverse the array:
  - `nums[0] = -2`: `currentSum = -2`, `maxSum = -2`, reset `currentSum = 0`.
  - `nums[1] = 1`: `currentSum = 1`, `maxSum = 1`.
  - `nums[2] = -3`: `currentSum = -2`, `maxSum = 1`, reset `currentSum = 0`.
  - `nums[3] = 4`: `currentSum = 4`, `maxSum = 4`.
  - `nums[4] = -1`: `currentSum = 3`, `maxSum = 4`.
  - `nums[5] = 2`: `currentSum = 5`, `maxSum = 5`.
  - `nums[6] = 1`: `currentSum = 6`, `maxSum = 6`.
  - `nums[7] = -5`: `currentSum = 1`, `maxSum = 6`.
  - `nums[8] = 4`: `currentSum = 5`, `maxSum = 6`.
### Input
```plaintext
nums = [1]
```
### Output
```plaintext
1
```
### Explanation
- The subarray `[1]` has the largest sum `1`.
### Input
```plaintext
nums = [5,4,-1,7,8]
```
### Output
```plaintext
23
```
### Explanation
- The subarray `[5,4,-1,7,8]` has the largest sum `23`.
# Dry Run
### Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
| Step | i   | nums[i] | currentSum | maxSum | Action             |     |
| ---- | --- | ------- | ---------- | ------ | ------------------ | --- |
| 1    | 0   | -2      | -2         | -2     | Reset currentSum=0 |     |
| 2    | 1   | 1       | 1          | 1      | -                  |     |
| 3    | 2   | -3      | -2         | 1      | Reset currentSum=0 |     |
| 4    | 3   | 4       | 4          | 4      | -                  |     |
| 5    | 4   | -1      | 3          | 4      | -                  |     |
| 6    | 5   | 2       | 5          | 5      | -                  |     |
| 7    | 6   | 1       | 6          | 6      | -                  |     |
| 8    | 7   | -5      | 1          | 6      | -                  |     |
| 9    | 8   | 4       | 5          | 6      | -                  |     |
Final result: `maxSum = 6`.
# Notes
- **Efficiency**:
  - Time Complexity: O(n), where `n` is the size of the array.
  - Space Complexity: O(1), as no extra space is used.
- **Algorithm**: Kadane's Algorithm is optimal for finding the maximum subarray sum.
- **Edge Cases**:
  - Array with all negative numbers: Return the largest (least negative) number.
  - Array with all positive numbers: Return the sum of all elements.
  - Single-element array: Return that element.