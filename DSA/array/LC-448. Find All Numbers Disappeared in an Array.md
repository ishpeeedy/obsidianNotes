
#DSA #DSA-easy #Leetcode #array #hashing #in-place
# Problem Statement
Given an array nums of n integers where nums[i] is in the range [1,n] return an array of all the integers in the range [1,n] that do not appear in nums
# Key Concepts
- Use frequency/counting to detect missing numbers within [1,n]
- Follow-up: mark visited indices in-place by negation to achieve O(1) extra space
- Preserve O(n) time by single or few passes over the array
# Implementation Steps
1. Create a frequency vector h of size n initialized to 0
2. Iterate nums and increment h[nums[i]-1] for each value
3. Iterate h and collect indices i where h[i]==0 then push i+1 to result
4. Return result
# Code Implementation
```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> h(nums.size(),0);
        vector<int> result;
        for (int i = 0; i < nums.size(); i++) {
            h[nums[i]-1]++;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (h[i] == 0) {
                result.push_back(i+1);
            }
        }
        return result;
    }
};
```
# Sample Input/Output
Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Input: nums = [1,1] Output: [2]
# Dry Run
nums=[4,3,2,7,8,2,3,1] n=8 h initial=[0,0,0,0,0,0,0,0] after counting: value4->h[3]=1 value3->h[2]=1 value2->h[1]=1 value7->h[6]=1 value8->h[7]=1 value2->h[1]=2 value3->h[2]=2 value1->h[0]=1 final h=[1,2,2,1,0,0,1,1] indices with 0 are 4 and 5 -> missing numbers [5,6]
# Notes
- Complexity: Time O(n) Space O(n) for this implementation
- Follow-up (O(1) extra space): iterate nums and for each v=abs(nums[i]) set nums[v-1] = -abs(nums[v-1]); second pass collect indices with positive values as missing. This preserves O(n) time and uses only output array as extra space
- Edge cases: n=1 and duplicates handled correctly