# Problem Statement
Given an array `nums` of size `n`, return the majority element.
The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.
#Array #DSA #DSA-easy #Leetcode 
# Key Concepts
- **Majority Element**: An element that appears more than `n / 2` times in the array.
- **Boyer-Moore Voting Algorithm**: An efficient algorithm to find the majority element in O(n) time and O(1) space.
- **Candidate Selection**: The algorithm selects a candidate and maintains a count. If the count becomes 0, a new candidate is selected.
# Implementation Steps
1. **Initialize Variables**:
   - `count = 0`: Tracks the count of the current candidate.
   - `element = 0`: Stores the current candidate for the majority element.
2. **Traverse the Array**:
   - If `count == 0`, set the current element as the new candidate and increment `count`.
   - If the current element equals the candidate, increment `count`.
   - If the current element differs from the candidate, decrement `count`.
3. **Return the Candidate**: After traversing the array, the candidate is the majority element.
# Code Implementation
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 0;
        int element = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (count == 0) {
                element = nums[i];
                count++;
            } else if (nums[i] == element) {
                count++;
            } else {
                count--;
            }
        }
        return element;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [3,2,3]
```
### Output
```plaintext
3
```
### Explanation
- Traverse the array:
  - `nums[0] = 3`: `count = 0` → Set `element = 3`, `count = 1`.
  - `nums[1] = 2`: `nums[1] != element` → Decrement `count = 0`.
  - `nums[2] = 3`: `count = 0` → Set `element = 3`, `count = 1`.
- Final result: `element = 3`.
### Input
```plaintext
nums = [2,2,1,1,1,2,2]
```
### Output
```plaintext
2
```
### Explanation
- Traverse the array:
  - `nums[0] = 2`: `count = 0` → Set `element = 2`, `count = 1`.
  - `nums[1] = 2`: `nums[1] == element` → Increment `count = 2`.
  - `nums[2] = 1`: `nums[2] != element` → Decrement `count = 1`.
  - `nums[3] = 1`: `nums[3] != element` → Decrement `count = 0`.
  - `nums[4] = 1`: `count = 0` → Set `element = 1`, `count = 1`.
  - `nums[5] = 2`: `nums[5] != element` → Decrement `count = 0`.
  - `nums[6] = 2`: `count = 0` → Set `element = 2`, `count = 1`.
- Final result: `element = 2`.
# Dry Run
### Input: nums = [2,2,1,1,1,2,2]
| Step | i | nums[i] | count | element | Action                     |
| ---- | - | ------- | ----- | ------- | -------------------------- |
| 1    | 0 | 2       | 0     | 0       | Set element=2, count=1     |
| 2    | 1 | 2       | 1     | 2       | Increment count=2          |
| 3    | 2 | 1       | 2     | 2       | Decrement count=1          |
| 4    | 3 | 1       | 1     | 2       | Decrement count=0          |
| 5    | 4 | 1       | 0     | 2       | Set element=1, count=1     |
| 6    | 5 | 2       | 1     | 1       | Decrement count=0          |
| 7    | 6 | 2       | 0     | 1       | Set element=2, count=1     |
Final result: `element = 2`.
# Notes
- **Efficiency**:
  - Time Complexity: O(n), where `n` is the size of the array.
  - Space Complexity: O(1), as no extra space is used.
- **Algorithm**: Boyer-Moore Voting Algorithm is optimal for finding the majority element.
- **Edge Cases**:
  - Array with all identical elements: Return the element.
  - Array with exactly `n/2 + 1` occurrences of the majority element: The algorithm correctly identifies it.
- **Assumption**: The problem guarantees that the majority element always exists in the array.