#DSA #DSA-easy #Leetcode #array #two-pointer #sorted-array
# Problem Statement
Given an integer array nums sorted in non-decreasing order return an array of the squares of each number sorted in non-decreasing order
# Key Concepts
- **Two-Pointer Technique**: Use left and right pointers to compare absolute values from both ends
- **Sorted Input**: Leverage the sorted property of the input array
- **Fill Result Backwards**: Since largest squared values come from the ends fill result array from right to left
- **O(n) Solution**: Avoid sorting after squaring by using two pointers to build result in sorted order
# Implementation Steps
1. **Initialize Result Array**: Create a result vector of same size as nums filled with 0
2. **Initialize Two Pointers**: Set left = 0 and right = nums.size() - 1
3. **Fill Result Backwards**:
   - Start from index i = nums.size() - 1 down to 0
   - Compare abs(nums[left]) with abs(nums[right])
   - If abs(nums[left]) > abs(nums[right]): place nums[left]² at result[i] and increment left
   - Else: place nums[right]² at result[i] and decrement right
4. **Return Result**: Return the filled result array
# Code Implementation
```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result(nums.size(), 0);
        int left = 0;
        int right = nums.size() - 1;
        for (int i = nums.size() - 1; i >= 0; i--) {
            if (abs(nums[left]) > abs(nums[right])) {
                result[i] = nums[left] * nums[left];
                left++;
            } else {
                result[i] = nums[right] * nums[right];
                right--;
            }
        }
        return result;
    }
};
```
# Sample Input/Output
### Input
```plaintext
nums = [-4,-1,0,3,10]
```
### Output
```plaintext
[0,1,9,16,100]
```
### Explanation
After squaring the array becomes [16,1,0,9,100] after sorting it becomes [0,1,9,16,100] using two pointers we build this directly without explicit sorting
### Input
```plaintext
nums = [-7,-3,2,3,11]
```
### Output
```plaintext
[4,9,9,49,121]
```
### Explanation
Compare absolute values from both ends and place larger squares at the end of result array working backwards
# Dry Run
### Input: nums = [-4,-1,0,3,10]
| Step | i | left | right | abs(nums[left]) | abs(nums[right]) | Action | result |
| ---- | - | ---- | ----- | --------------- | ---------------- | ------ | ------ |
| 1 | 4 | 0 | 4 | 4 | 10 | 10² at result[4] | [0,0,0,0,100] |
| 2 | 3 | 0 | 3 | 4 | 3 | 4² at result[3] | [0,0,0,16,100] |
| 3 | 2 | 1 | 3 | 1 | 3 | 3² at result[2] | [0,0,9,16,100] |
| 4 | 1 | 1 | 2 | 1 | 0 | 1² at result[1] | [0,1,9,16,100] |
| 5 | 0 | 2 | 2 | 0 | 0 | 0² at result[0] | [0,1,9,16,100] |
Final result: [0,1,9,16,100]
# Notes
- **Efficiency**:
  - Time Complexity: O(n) single pass through the array
  - Space Complexity: O(n) for the result array (not counting output as extra space)
- **Key Insight**: Since input is sorted largest absolute values are at the ends so we can build sorted squares from largest to smallest
- **Edge Cases**:
  - All negative numbers: Works correctly by comparing absolute values
  - All positive numbers: Works correctly right pointer provides all values
  - Mix of negative and positive: Handles correctly by absolute value comparison
- **Follow-up Answer**: This solution achieves O(n) time without explicit sorting by leveraging the sorted property and two pointers