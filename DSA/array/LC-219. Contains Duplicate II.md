# 219. Contains Duplicate II
#array #hash-map #sliding-window #DSA #DSA-easy #Leetcode
# Problem Statement
Given an integer array nums and an integer k return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k
# Key Concepts
- **Hash Map**: Use unordered_map to store element values and their most recent indices
- **Index Distance**: Check if the distance between current index and stored index is within k
- **Sliding Window**: Effectively maintain a window of at most k elements by updating indices
- **Early Termination**: Return true immediately when condition is satisfied
# Implementation Steps
1. **Initialize Hash Map**: Create an empty unordered_map to store elements and their indices
2. **Traverse the Array**:
   - For each element at index i check if it exists in the map using count()
   - If found calculate the distance abs(i - m[nums[i]])
   - If distance <= k return true (duplicate within range found)
   - Store or update the current element's index in the map
3. **Return False**: If loop completes without finding valid duplicate pair return false
# Code Implementation
````cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); i++) {
            if (m.count(nums[i]) && abs(i - m[nums[i]]) <= k) {
                return true;
            }
            m[nums[i]] = i;
        }
        return false;
    }
};