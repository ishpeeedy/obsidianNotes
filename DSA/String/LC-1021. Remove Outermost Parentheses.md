# 1021. Remove Outermost Parentheses
#DSA #DSA-easy #Leetcode #string #stack #parentheses
# Problem Statement
A valid parentheses string is either empty "", "(" + A + ")", or A + B, where A and B are valid parentheses strings. A valid parentheses string s is primitive if it is nonempty and there does not exist a way to split it into s = A + B with A and B nonempty valid parentheses strings. Given a valid parentheses string s consider its primitive decomposition s = P1 + P2 + ... + Pk where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.
# Key Concepts
- **Level/Depth Tracking**: Use a counter to track nesting level of parentheses
- **Primitive Detection**: A primitive string starts and ends when level reaches 0
- **Outermost Identification**: Skip adding parentheses when level is at boundary (level==0 for opening or level==1 for closing after decrement)
- **String Building**: Build result string by selectively adding non-outermost parentheses
# Implementation Steps
1. **Initialize Variables**: Create empty result string and level counter set to 0
2. **Traverse String**:
   - For each character ch in s
   - If ch is '(':
     - If level > 0 add ch to result (not outermost opening)
     - Increment level
   - If ch is ')':
     - Decrement level
     - If level > 0 add ch to result (not outermost closing)
3. **Return Result**: Return the constructed result string
# Code Implementation
```cpp
class Solution {
public:
    string removeOuterParentheses(string s) {
        string result = "";
        int level = 0;
        for (char ch : s) {
            if (ch == '(') {
                if (level > 0) result += ch;
                level++;
            } else if (ch == ')') {
                level--;
                if (level > 0) result += ch;
            }
        }
        return result;
    }
};
```
# Sample Input/Output
### Input
```plaintext
s = "(()())(())"
```
### Output
```plaintext
"()()()"
```
### Explanation
Primitive decomposition: "(()())" + "(())". After removing outer parentheses: "()()" + "()" = "()()()".
### Input
```plaintext
s = "(()())(())(()(()))"
```
### Output
```plaintext
"()()()()(())"
```
### Explanation
Primitive decomposition: "(()())" + "(())" + "(()(()))". After removing outer parentheses: "()()" + "()" + "()(())" = "()()()()(())".
### Input
```plaintext
s = "()()"
```
### Output
```plaintext
""
```
### Explanation
Primitive decomposition: "()" + "()". After removing outer parentheses: "" + "" = "".
# Dry Run
### Input: s = "(()())(())"
| Step | ch | level (before) | Action | level (after) | result |
| ---- | -- | -------------- | ------ | ------------- | ------ |
| 1 | ( | 0 | Skip add, level++ | 1 | "" |
| 2 | ( | 1 | Add ch, level++ | 2 | "(" |
| 3 | ) | 2 | level--, add ch | 1 | "()" |
| 4 | ( | 1 | Add ch, level++ | 2 | "()(" |
| 5 | ) | 2 | level--, add ch | 1 | "()()" |
| 6 | ) | 1 | level--, skip add | 0 | "()()" |
| 7 | ( | 0 | Skip add, level++ | 1 | "()()" |
| 8 | ( | 1 | Add ch, level++ | 2 | "()()(" |
| 9 | ) | 2 | level--, add ch | 1 | "()()()" |
| 10 | ) | 1 | level--, skip add | 0 | "()()()" |
Final result: "()()()"
# Notes
- **Efficiency**:
  - Time Complexity: O(n) single pass through the string
  - Space Complexity: O(n) for the result string
- **Key Insight**: Level/depth counter identifies primitive boundaries when level== 0 occurs we've completed a primitive substring
- **Why It Works**:
  - Opening '(' at level 0 is outermost opening skip it
  - Closing ')' that brings level to 0 is outermost closing skip it
  - All other parentheses are internal keep them
- **Edge Cases**:
  - Single primitive "()" returns ""
  - Nested primitives handled correctly by level tracking
  - Multiple primitives concatenated work seamlessly