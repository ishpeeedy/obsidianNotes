# 151. Reverse Words in a String
#DSA #DSA-medium #Leetcode #string #two-pointer #reverse
# Problem Statement
Given an input string s reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.
# Key Concepts
- **Two-Pointer Technique**: Use left and right pointers to skip leading and trailing spaces
- **Word Extraction**: Build words character by character until space is encountered
- **Reverse Order Construction**: Prepend each word to result string to achieve reverse order
- **Space Normalization**: Handle multiple spaces between words by checking if currentWord is non-empty before adding
# Implementation Steps
1. **Initialize Variables**: Create empty strings currentWord and answer, set left=0 and right=s.size()-1
2. **Skip Leading Spaces**: Move left pointer forward while s[left] is space
3. **Skip Trailing Spaces**: Move right pointer backward while s[right] is space
4. **Traverse and Build Words**:
   - While left <= right
   - If s[left] is not space add to currentWord
   - If s[left] is space and currentWord is not empty:
     - Prepend currentWord to answer with space separator (if answer is not empty)
     - Reset currentWord to empty
   - Increment left
5. **Handle Last Word**: After loop if currentWord is not empty prepend it to answer
6. **Return Result**: Return the answer string
# Code Implementation
```cpp
class Solution {
public:
    string reverseWords(string s) {
        string currentWord = "";
        string answer = "";
        int left = 0;
        int right = s.size() - 1;
        while (left <= right && s[left] == ' ') left++;
        while (right >= left && s[right] == ' ') right--;
        while (left <= right) {
            if (s[left] != ' ') {
                currentWord += s[left];
            } else {
                if (currentWord != "") {
                    if (answer != "")
                        answer = currentWord + " " + answer;
                    else
                        answer = currentWord;
                    currentWord = "";
                }
            }
            left++;
        }
        if (currentWord != "") {
            if (answer != "")
                answer = currentWord + " " + answer;
            else
                answer = currentWord;
        }
        return answer;
    }
};
```
# Sample Input/Output
### Input
```plaintext
s = "the sky is blue"
```
### Output
```plaintext
"blue is sky the"
```
### Explanation
Words are extracted in order: "the", "sky", "is", "blue". Each word is prepended to answer resulting in reverse order.
### Input
```plaintext
s = "  hello world  "
```
### Output
```plaintext
"world hello"
```
### Explanation
Leading and trailing spaces are skipped. Words "hello" and "world" are extracted and reversed.
### Input
```plaintext
s = "a good   example"
```
### Output
```plaintext
"example good a"
```
### Explanation
Multiple spaces between words are handled by only adding non-empty words to answer.
# Dry Run
### Input: s = "the sky is blue"
| Step | left | s[left] | currentWord | answer | Action |
| ---- | ---- | ------- | ----------- | ------ | ------ |
| Skip leading spaces | 0 | 't' | "" | "" | No spaces to skip |
| 1 | 0 | 't' | "t" | "" | Add to currentWord |
| 2 | 1 | 'h' | "th" | "" | Add to currentWord |
| 3 | 2 | 'e' | "the" | "" | Add to currentWord |
| 4 | 3 | ' ' | "the" | "the" | Space found, prepend word |
| 5 | 4 | 's' | "s" | "the" | Add to currentWord |
| 6 | 5 | 'k' | "sk" | "the" | Add to currentWord |
| 7 | 6 | 'y' | "sky" | "the" | Add to currentWord |
| 8 | 7 | ' ' | "sky" | "sky the" | Space found, prepend word |
| 9 | 8 | 'i' | "i" | "sky the" | Add to currentWord |
| 10 | 9 | 's' | "is" | "sky the" | Add to currentWord |
| 11 | 10 | ' ' | "is" | "is sky the" | Space found, prepend word |
| 12 | 11 | 'b' | "b" | "is sky the" | Add to currentWord |
| 13 | 12 | 'l' | "bl" | "is sky the" | Add to currentWord |
| 14 | 13 | 'u' | "blu" | "is sky the" | Add to currentWord |
| 15 | 14 | 'e' | "blue" | "is sky the" | Add to currentWord |
| After loop | - | - | "blue" | "blue is sky the" | Prepend last word |
Final result: "blue is sky the"
## Important Notes from Your Doubts
- **Double/multiple spaces**: Handled automatically because we **only add non-empty words** (`currentWord != ""`). Extra spaces are skipped.
- **Prepending check (`if(answer != "")`)**: Needed to avoid extra space at the end.
- **Character vs string comparison**: Use `' '` (char literal), not `" "` (string literal).
- **Infinite loops / TLE**: Ensure `while` loops increment indexes in all cases; do **not** use `if` inside a loop without advancing the pointer.
# Notes
- **Efficiency**:
  - Time Complexity: O(n) where n is length of string
  - Space Complexity: O(n) for storing result and temporary words
- **Key Techniques**:
  - Prepending words to answer string achieves reverse order without explicit reversal
  - Skipping leading/trailing spaces ensures clean output
  - Checking currentWord != "" handles multiple consecutive spaces
- **Edge Cases**:
  - Single word: Returns the word itself
  - Multiple spaces between words: Normalized to single space
  - Leading/trailing spaces: Removed correctly
- **Follow-up (O(1) space)**: For mutable strings reverse entire string then reverse each word in-place and remove extra spaces in-place