# 1903. Largest Odd Number in String
#DSA #DSA-easy #Leetcode #string #greedy #math
# Problem Statement
You are given a string num representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num or an empty string "" if no odd integer exists. A substring is a contiguous sequence of characters within a string.
# Key Concepts
- **Odd Number Property**: A number is odd if its last digit is odd (1,3,5,7,9)
- **Greedy Approach**: To get the largest odd substring scan from right to left and find the first odd digit
- **Substring from Start**: The largest odd number will always be from index 0 to the first odd digit from the right
- **Character to Digit**: Use modulo operation on character to check if digit is odd (num[i]%2==0 checks if even)
# Implementation Steps
1. **Initialize Pointer**: Set i = num.size()-1 to start from the last character
2. **Find First Odd Digit from Right**:
   - While i >= 0 and num[i] is even (num[i]%2==0)
   - Decrement i
3. **Check Result**:
   - If i < 0 no odd digit found return empty string ""
   - Otherwise return substring from 0 to i+1 using num.substr(0,i+1)
4. **Return Result**: Return the substring or empty string
# Code Implementation
```cpp
class Solution {
public:
    string largestOddNumber(string num) {
        int i = num.size()-1;
        while (i >= 0 && num[i] % 2 == 0) {
            i--;
        }
        if (i < 0) {
            return "";
        }
        return num.substr(0, i+1);
    }
};
```
# Sample Input/Output
### Input
```plaintext
num = "52"
```
### Output
```plaintext
"5"
```
### Explanation
Scan from right: '2' is even skip it. '5' is odd return substring from 0 to index 0 which is "5".
### Input
```plaintext
num = "4206"
```
### Output
```plaintext
""
```
### Explanation
All digits are even (4,2,0,6) no odd digit found return empty string.
### Input
```plaintext
num = "35427"
```
### Output
```plaintext
"35427"
```
### Explanation
Last digit '7' is odd return entire string from 0 to index 4 which is "35427".
# Dry Run
### Input: num = "52"
| Step | i | num[i] | num[i]%2 | Action |
| ---- | - | ------ | -------- | ------ |
| 1 | 1 | '2' | 0 (even) | Decrement i |
| 2 | 0 | '5' | 1 (odd) | Exit loop |
| 3 | 0 | - | - | Return substr(0,1) = "5" |
Final result: "5"
### Input: num = "4206"
| Step | i | num[i] | num[i]%2 | Action |
| ---- | - | ------ | -------- | ------ |
| 1 | 3 | '6' | 0 (even) | Decrement i |
| 2 | 2 | '0' | 0 (even) | Decrement i |
| 3 | 1 | '2' | 0 (even) | Decrement i |
| 4 | 0 | '4' | 0 (even) | Decrement i |
| 5 | -1 | - | - | i < 0 return "" |
Final result: ""
### Input: num = "35427"
| Step | i | num[i] | num[i]%2 | Action |
| ---- | - | ------ | -------- | ------ |
| 1 | 4 | '7' | 1 (odd) | Exit loop immediately |
| 2 | 4 | - | - | Return substr(0,5) = "35427" |
Final result: "35427"
# Notes
- **Efficiency**:
  - Time Complexity: O(n) worst case scan entire string from right
  - Space Complexity: O(1) only using pointer variable (output string not counted)
- **Key Insight**: The largest odd number must end at the rightmost odd digit. Any substring starting from 0 and ending at an odd digit will be larger than substrings that don't start from 0.
- **Character Arithmetic**: num[i]%2 works because character digits '0'-'9' have ASCII values where their modulo 2 matches the digit's parity
- **Edge Cases**:
  - All even digits: Return ""
  - Single digit odd: Return that digit
  - Already odd number: Return entire string
  - Large numbers up to 10^5 length: Handled efficiently