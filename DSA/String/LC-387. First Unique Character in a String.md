# 387. First Unique Character in a String
#DSA #DSA-easy #Leetcode #string #hash-map #frequency-count
# Problem Statement
Given a string s find the first non-repeating character in it and return its index. If it does not exist return -1.
# Key Concepts
- **Frequency Counting**: Use hash map to count occurrences of each character
- **Two-Pass Approach**: First pass to build frequency map second pass to find first character with count 1
- **First Occurrence**: Return the first index where character count equals 1
- **No Unique Character**: Return -1 if all characters repeat
# Implementation Steps
1. **Build Frequency Map**: Create unordered_map<char,int> and count frequency of each character in s
2. **Traverse String Again**: Iterate through s from left to right
3. **Check Frequency**: For each character check if its frequency in map equals 1
4. **Return First Unique**: If found return its index immediately
5. **No Unique Found**: If loop completes return -1
# Code Implementation
```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char, int> h;
        for (int i = 0; i < s.size(); i++) {
            h[s[i]]++;
        }
        for (int i = 0; i < s.size(); i++) {
            if (h[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};
```
# Sample Input/Output
### Input
```plaintext
s = "leetcode"
```
### Output
```plaintext
0
```
### Explanation
The character 'l' at index 0 occurs only once in the string. It is the first non-repeating character.
### Input
```plaintext
s = "loveleetcode"
```
### Output
```plaintext
2
```
### Explanation
The character 'v' at index 2 is the first character that appears only once.
### Input
```plaintext
s = "aabb"
```
### Output
```plaintext
-1
```
### Explanation
All characters repeat (a appears twice b appears twice). No unique character exists.
# Dry Run
### Input: s = "leetcode"
#### Build Frequency Map
| Step | i | s[i] | h after increment |
| ---- | - | ---- | ----------------- |
| 1 | 0 | 'l' | {l:1} |
| 2 | 1 | 'e' | {l:1,e:1} |
| 3 | 2 | 'e' | {l:1,e:2} |
| 4 | 3 | 't' | {l:1,e:2,t:1} |
| 5 | 4 | 'c' | {l:1,e:2,t:1,c:1} |
| 6 | 5 | 'o' | {l:1,e:2,t:1,c:1,o:1} |
| 7 | 6 | 'd' | {l:1,e:2,t:1,c:1,o:1,d:1} |
| 8 | 7 | 'e' | {l:1,e:3,t:1,c:1,o:1,d:1} |
#### Find First Unique
| Step | i | s[i] | h[s[i]] | Action |
| ---- | - | ---- | ------- | ------ |
| 1 | 0 | 'l' | 1 | Found! Return 0 |
Final result: 0
### Input: s = "aabb"
#### Build Frequency Map
Final map: {a:2, b:2}
#### Find First Unique
| Step | i | s[i] | h[s[i]] | Action |
| ---- | - | ---- | ------- | ------ |
| 1 | 0 | 'a' | 2 | Not unique, continue |
| 2 | 1 | 'a' | 2 | Not unique, continue |
| 3 | 2 | 'b' | 2 | Not unique, continue |
| 4 | 3 | 'b' | 2 | Not unique, continue |
Loop completes without finding unique character
Final result: -1
# Notes
- **Efficiency**:
  - Time Complexity: O(n) two passes through the string where n is length of s
  - Space Complexity: O(1) or O(26) at most 26 lowercase letters stored in hash map
- **Two-Pass Strategy**: First pass builds complete frequency information second pass finds first unique in original order
- **Why Hash Map**: Provides O(1) lookup and update for character frequencies
- **Preserving Order**: Second loop through original string ensures we find the first occurrence in left-to-right order
- **Edge Cases**:
  - Single character string: Returns 0 (unique by default)
  - All characters unique: Returns 0 (first character)
  - All characters repeat: Returns -1
  - Empty string: Not possible per constraints (1 <= s.length)
- **Alternative Approach**: Could use array of size 26 for frequency count instead of hash map for slightly better performance