# 242. Valid Anagram
#DSA #DSA-easy #Leetcode #string #hash-map #sorting
# Problem Statement
Given two strings s and t return true if t is an anagram of s and false otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once.
# Key Concepts
- **Anagram Definition**: Two strings are anagrams if they contain the same characters with the same frequencies
- **Hash Map Approach**: Use unordered_map to count character frequencies and compare
- **Frequency Comparison**: Two maps are equal if all key-value pairs match
- **Alternative**: Sort both strings and compare for equality
# Implementation Steps
### Approach 1: Hash Map Comparison
1. **Check Length**: If s.length() != t.length() return false immediately
2. **Build Frequency Maps**: Create two unordered_map<char,int> for s and t
3. **Count Frequencies**:
   - Iterate through s and increment hashs[ch]
   - Iterate through t and increment hasht[ch]
4. **Compare Maps**: Return hashs == hasht
### Approach 2: Sorting
1. **Sort Both Strings**: Sort s and t using sort()
2. **Compare Sorted Strings**: Return s == t
# Code Implementation
### Approach 1: Hash Map
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) return false;
        unordered_map<char,int> hashs;
        unordered_map<char,int> hasht;
        for (auto ch : s) {
            hashs[ch]++;
        }
        for (auto ch : t) {
            hasht[ch]++;
        }
        return hashs == hasht;
    }
};
```
### Approach 2: Sorting
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) return false;
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```
# Sample Input/Output
### Input
```plaintext
s = "anagram", t = "nagaram"
```
### Output
```plaintext
true
```
### Explanation
Both strings contain: a:3, n:1, g:1, r:1, m:1. Character frequencies match so they are anagrams.
### Input
```plaintext
s = "rat", t = "car"
```
### Output
```plaintext
false
```
### Explanation
s contains r:1, a:1, t:1. t contains c:1, a:1, r:1. Frequencies don't match (t vs c) so not anagrams.
# Dry Run
### Input: s = "anagram", t = "nagaram"
#### Hash Map Approach
Build hashs: a→3, n→1, g→1, r→1, m→1
Build hasht: n→1, a→3, g→1, r→1, m→1
Compare: hashs == hasht → true
#### Sorting Approach
Sort s: "anagram" → "aaagmnr"
Sort t: "nagaram" → "aaagmnr"
Compare: "aaagmnr" == "aaagmnr" → true
Final result: true
### Input: s = "rat", t = "car"
#### Hash Map Approach
Build hashs: r→1, a→1, t→1
Build hasht: c→1, a→1, r→1
Compare: hashs != hasht → false (t vs c key mismatch)
Final result: false
# Notes
- **Efficiency**:
  - Hash Map Approach:
    - Time Complexity: O(n) where n is length of strings
    - Space Complexity: O(1) since at most 26 lowercase letters stored
  - Sorting Approach:
    - Time Complexity: O(n log n) due to sorting
    - Space Complexity: O(1) or O(n) depending on sort implementation
- **Best Approach**: Hash map is more efficient for large inputs
- **Map Comparison**: C++ allows direct comparison of unordered_map which checks if all key-value pairs match
- **Early Exit**: Length check avoids unnecessary computation
- **Edge Cases**:
  - Empty strings: Both empty returns true
  - Single character: Works correctly
  - All same character: Correctly counts frequencies
  - Different lengths: Returns false immediately